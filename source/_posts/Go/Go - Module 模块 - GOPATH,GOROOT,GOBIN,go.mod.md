---
title: Go - Module 模块 - GOPATH,GOROOT,GOBIN,go.mod
categories:
- Go
tags:
- Go
- module
date: 2020-03-01 16:49:07
---

Go - Module 模块 - GOPATH,GOROOT,GOBIN,go.mod

<!--more-->

显示模块说明：
```
go help modules
```

Go 以前使用 GOPATH 来指定给定的版本需要哪些源文件，后来被模块代替。

Go 模块是一些相关包 (package) 的集合，模块也是交换源代码的基本单位。

所有的 go 命令都内置了对模块的支持，可以记录和解决对其他模块的依赖。

## GOPATH



## 模块支持

### go.mod 文件

在当前目录或父目录中找到 go.mod 文件时，默认情况下会激活模块感知模式。

使用模块的最快方式，就是在代码目录下创建一个 `go.mod` 文件，然后在这个目录树下运
行相关的 go 命令。

### GO111MODULE

go 命令目前仍然支持临时环境变量：`GO111MODULE`，其取值为字符串，有 3 个：
* on
* off
* auto，此为默认值

**GO111MODULE=on**

此时 go 命令运行于模块感知模式，Go 代码需要使用模块，而不会考虑 GOPATH

**GO111MODULE=off**

此时 go 命令运行于 GOPATH 模式，go 命令不会启用模块支持，而是去供应商目录和
GOPATH 指定的目录寻找依赖。

**GO111MODULE=auto**

设置为 auto 或没设置值时，go 命令启用还是禁用模块支持取决于当前的运行目录：如果
当前的目录包含 `go.mod` 文件，或当前的目录是包含 `go.mod` 文件目录的子目录，则启
用模块支持。

### 注意

在模块感知模式下，GOPATH 不再对编译期间的 import 语句导入依赖路径起作用，但是仍
然在 `GOPATH/pkg/mod` 目录下存储了下载的依赖，仍然会安装命令到 `GOPATH/bin` 目录
下(除非设置了 GOBIN)

## 定义模块

在 Go 源文件的根目录下放一个 `go.mod` 文件，这个 `go.mod` 文件再加上 Go 源文件的
目录树就定义了一个 Go 模块。

包含 `go.mod` 文件的目录称为模块的根目录，通常模块根目录也对应一个源代码根，但也
不是必需。

Go 模块是模块根目录下所有 Go 包和其子目录下所有 Go 包的集合，但注意不包括那些有自
己的 `go.mod` 文件的子目录树。

模块的路径是导入模块时的路径前缀，是相对于模块根目录的。

`go.mod` 文件定义了当前模块的路径，并通过模块路径和版本号的方式列出了需要导入的其
他模块和其版本号。

例如，下面的 `go.mod` 文件声明了包含它的目录是模块的根目录，模块路径是
`example.com/m`，并且声明了依赖的特定版本的两个模块：

	module example.com/m

	require (
		golang.org/x/text v0.3.0
		gopkg.in/yaml.v2 v2.1.0
	)

`go.mod` 文件还可以指定替换和排除的模块版本号，但是只在直接编译此模块时起作用，
若此模块被纳入一个更大的编译时，则这些设置会被忽略。

最简单的模块，在模块的根目录下创建一个 `go.mod` 文件，然后写入一条 `module` 语句
，例如：`module example.com/m`，也可以使用命令完成上述过程：
```
go mod init example.com/m
```

> 如果一个工程中使用了依赖管理工具，如 godep, glide, dep， 则 `go mod init` 命令
> 会根据已存在的设置自动添加相关的 require 语句。

一旦 `go.mod` 文件建立，则无需其他额外步骤，go 命令像 `go build`, `go test`, `go
list` 会自动添加需要的新依赖来满足导入操作。

## The main module and the build list

一个程序项目可以包括多个模块，其中一个模块必须是主模块 main module，作为程序的执
行入口，例如若 go 去 x 目录下执行 `go run ...` 之类的命令来启动程序，则包含了 x 
目录的模块就是主模块，go 命令通过从当前目录逐级向上查找 `go.mod` 文件来找到主模
块的根目录。

主模块的 `go.mod` 文件可以通过 `require`， `replace`， `exclude` 语句精确的定义
可供 go 命令使用的包的集合，而 `require` 语句定义的依赖模块也有自己的 `go.mod` 
文件，但这些依赖模块这时不是作为独立模块，而是作为主模块的子模块，这时依赖模块中
定义的 `replace` 和 `exclude` 语句都会被忽略，而只考虑 `require` 语句，这种处理
方式可以让主模块完全控制其自身的构建，而不是还要受依赖模块的控制。

提供了构建程序时所需包的模块集合，称为构建列表 build list。构建列表最开始只包含
主模块，然后 go 命令把主模块中要求的依赖模块版本添加到构建列表，然后再去递归的找
这些依赖模块的依赖模块，直至所有依赖模块添加完成。

如果一个模块有多个版本被添加到构建列表，则只保留最新的版本(根据语义版本排序)。

`go list` 命令提供了主模块和构建列表的信息：

	go list -m              # print path of main module
	go list -m -f={{.Dir}}  # print root directory of main module
	go list -m all          # print build list

## Maintaining module requirements

`go.mod` 文件既可以被程序员读取和更改，也可以被命令程序读取和更改，go 命令会自动
的更新 `go.mod` 文件，以维持 `go.mod` 文件的标准格式和 `require` 语句的准确性。

任何 go 命令发现了不熟悉的 import 语句，都会查找包含这条 import 语句的模块，并把
此模块的最新版本自动添加到 `go.mod` 文件，因此，根据上述描述的规则，在大多数情况
下，只需要在源代码中添加 import 语句，然后运行 `go build`, `go test`, 甚至是
`go list` 即可，因为 go 命令会分析软件包，发现不熟悉的 import 语句并解决依赖，最
后自动更新到`go.mod` 文件。

当 go 命令添加依赖模块时很容易，因为 go 命令只需要检测到一条 import 语句导入了一
个包，然后 go 命令就可以把包含这个包的模块添加到构建列表，然而，从构建列表移除一
个模块却不像添加这么容易，因为要确定此模块真的不再被依赖，则需要确定此模块中包含
的每一个包都不再被依赖，就需要一个此模块的全局视图，包括了所有可能的构建配置(架
构、操作系统、构建标签等)。命令 `go mod tidy` 就可以构建这样的全局视图，然后基于
此视图添加缺少的模块，移除不需要的模块。

go 命令在维护 `go.mod` 中的 `require` 语句时，会跟踪哪些依赖模块提供的包是被当前
模块直接导入的，哪些依赖模块提供的包只是被通过二三层级的依赖模块间接使用的，后者
在 `go.mod` 文件中会被注释标明：`// indirect`，且一旦直接导入的依赖包隐含了这些
间接导入的依赖包，则间接导入的依赖包会自动的被从 `go.mod` 文件中移除。

只有在下列两种情况时，间接依赖的模块才会出现在 `go.mod` 文件中：
* 当使用的模块无法说明其自身的依赖关系
* 当把一个模块的依赖显式的升级后超过了它声明的需求

由于上述的自动维护规则，`go.mod` 文件中的信息是当前构建的最新的可读性描述。

`go get` 命令更新 `go.mod` 文件以更改构建中使用的模块版本。一个模块的升级可能意
味着也要升级其他模块，同样，一个模块的降级可能意味着也要降级其他模块，`go get`
命令也会进行这些隐式的升降级。

如果直接编辑 `go.mod` 文件，类似 `go build` 和 `go list` 这样的命令会假定要进行
升级，并自动的进行任何隐式的升级，同时同步修改 `go.mod` 中的版本号。


构建标记 `-mod` 对更新和使用 `go.mod` 文件提供了更多控制：

If invoked with -mod=readonly, the go command is disallowed from the implicit automatic updating of go.mod described above. Instead, it fails when any changes to go.mod are needed. This setting is most useful to check that go.mod does not need updates, such as in a continuous integration and testing system.  The "go get" command remains permitted to update go.mod even with -mod=readonly, and the "go mod" commands do not take the -mod flag (or any other build flags).

If invoked with -mod=vendor, the go command loads packages from the main module's vendor directory instead of downloading modules to and loading packages from the module cache. The go command assumes the vendor directory holds correct copies of dependencies, and it does not compute the set of required module versions from go.mod files. However, the go command does check that vendor/modules.txt (generated by 'go mod vendor') contains metadata consistent with go.mod.

If invoked with -mod=mod, the go command loads modules from the module cache even if there is a vendor directory present.

If the go command is not invoked with a -mod flag and the vendor directory is present and the "go" version in go.mod is 1.14 or higher, the go command will act as if it were invoked with -mod=vendor.

## Pseudo-versions

The go.mod file and the go command more generally use semantic versions as
the standard form for describing module versions, so that versions can be
compared to determine which should be considered earlier or later than another.
A module version like v1.2.3 is introduced by tagging a revision in the
underlying source repository. Untagged revisions can be referred to
using a "pseudo-version" like v0.0.0-yyyymmddhhmmss-abcdefabcdef,
where the time is the commit time in UTC and the final suffix is the prefix
of the commit hash. The time portion ensures that two pseudo-versions can
be compared to determine which happened later, the commit hash identifes
the underlying commit, and the prefix (v0.0.0- in this example) is derived from
the most recent tagged version in the commit graph before this commit.

There are three pseudo-version forms:

vX.0.0-yyyymmddhhmmss-abcdefabcdef is used when there is no earlier
versioned commit with an appropriate major version before the target commit.
(This was originally the only form, so some older go.mod files use this form
even for commits that do follow tags.)

vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef is used when the most
recent versioned commit before the target commit is vX.Y.Z-pre.

vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef is used when the most
recent versioned commit before the target commit is vX.Y.Z.

Pseudo-versions never need to be typed by hand: the go command will accept
the plain commit hash and translate it into a pseudo-version (or a tagged
version if available) automatically. This conversion is an example of a
module query.

## Module queries

The go command accepts a "module query" in place of a module version
both on the command line and in the main module's go.mod file.
(After evaluating a query found in the main module's go.mod file,
the go command updates the file to replace the query with its result.)

A fully-specified semantic version, such as "v1.2.3",
evaluates to that specific version.

A semantic version prefix, such as "v1" or "v1.2",
evaluates to the latest available tagged version with that prefix.

A semantic version comparison, such as "<v1.2.3" or ">=v1.5.6",
evaluates to the available tagged version nearest to the comparison target
(the latest version for < and <=, the earliest version for > and >=).

The string "latest" matches the latest available tagged version,
or else the underlying source repository's latest untagged revision.

The string "upgrade" is like "latest", but if the module is
currently required at a later version than the version "latest"
would select (for example, a newer pre-release version), "upgrade"
will select the later version instead.

The string "patch" matches the latest available tagged version
of a module with the same major and minor version numbers as the
currently required version. If no version is currently required,
"patch" is equivalent to "latest".

A revision identifier for the underlying source repository, such as
a commit hash prefix, revision tag, or branch name, selects that
specific code revision. If the revision is also tagged with a
semantic version, the query evaluates to that semantic version.
Otherwise the query evaluates to a pseudo-version for the commit.
Note that branches and tags with names that are matched by other
query syntax cannot be selected this way. For example, the query
"v2" means the latest version starting with "v2", not the branch
named "v2".

All queries prefer release versions to pre-release versions.
For example, `"<v1.2.3"` will prefer to return "v1.2.2"
instead of "v1.2.3-pre1", even though "v1.2.3-pre1" is nearer
to the comparison target.

Module versions disallowed by exclude statements in the
main module's go.mod are considered unavailable and cannot
be returned by queries.

For example, these commands are all valid:

	go get github.com/gorilla/mux@latest    # same (@latest is default for 'go get')
	go get github.com/gorilla/mux@v1.6.2    # records v1.6.2
	go get github.com/gorilla/mux@e3702bed2 # records v1.6.2
	go get github.com/gorilla/mux@c856192   # records v0.0.0-20180517173623-c85619274f5d
	go get github.com/gorilla/mux@master    # records current meaning of master

## Module compatibility and semantic versioning

The go command requires that modules use semantic versions and expects that
the versions accurately describe compatibility: it assumes that v1.5.4 is a
backwards-compatible replacement for v1.5.3, v1.4.0, and even v1.0.0.
More generally the go command expects that packages follow the
"import compatibility rule", which says:

"If an old package and a new package have the same import path,
the new package must be backwards compatible with the old package."

Because the go command assumes the import compatibility rule,
a module definition can only set the minimum required version of one
of its dependencies: it cannot set a maximum or exclude selected versions.
Still, the import compatibility rule is not a guarantee: it may be that
v1.5.4 is buggy and not a backwards-compatible replacement for v1.5.3.
Because of this, the go command never updates from an older version
to a newer version of a module unasked.

In semantic versioning, changing the major version number indicates a lack
of backwards compatibility with earlier versions. To preserve import
compatibility, the go command requires that modules with major version v2
or later use a module path with that major version as the final element.
For example, version v2.0.0 of example.com/m must instead use module path
example.com/m/v2, and packages in that module would use that path as
their import path prefix, as in example.com/m/v2/sub/pkg. Including the
major version number in the module path and import paths in this way is
called "semantic import versioning". Pseudo-versions for modules with major
version v2 and later begin with that major version instead of v0, as in
v2.0.0-20180326061214-4fc5987536ef.

As a special case, module paths beginning with gopkg.in/ continue to use the
conventions established on that system: the major version is always present,
and it is preceded by a dot instead of a slash: gopkg.in/yaml.v1
and gopkg.in/yaml.v2, not gopkg.in/yaml and gopkg.in/yaml/v2.

The go command treats modules with different module paths as unrelated:
it makes no connection between example.com/m and example.com/m/v2.
Modules with different major versions can be used together in a build
and are kept separate by the fact that their packages use different
import paths.

In semantic versioning, major version v0 is for initial development,
indicating no expectations of stability or backwards compatibility.
Major version v0 does not appear in the module path, because those
versions are preparation for v1.0.0, and v1 does not appear in the
module path either.

Code written before the semantic import versioning convention
was introduced may use major versions v2 and later to describe
the same set of unversioned import paths as used in v0 and v1.
To accommodate such code, if a source code repository has a
v2.0.0 or later tag for a file tree with no go.mod, the version is
considered to be part of the v1 module's available versions
and is given an +incompatible suffix when converted to a module
version, as in v2.0.0+incompatible. The +incompatible tag is also
applied to pseudo-versions derived from such versions, as in
v2.0.1-0.yyyymmddhhmmss-abcdefabcdef+incompatible.

In general, having a dependency in the build list (as reported by 'go list -m all')
on a v0 version, pre-release version, pseudo-version, or +incompatible version
is an indication that problems are more likely when upgrading that
dependency, since there is no expectation of compatibility for those.

See https://research.swtch.com/vgo-import for more information about
semantic import versioning, and see https://semver.org/ for more about
semantic versioning.

## Module code layout

For now, see https://research.swtch.com/vgo-module for information
about how source code in version control systems is mapped to
module file trees.

## Module downloading and verification

The go command can fetch modules from a proxy or connect to source control
servers directly, according to the setting of the GOPROXY environment
variable (see 'go help env'). The default setting for GOPROXY is
"https://proxy.golang.org,direct", which means to try the
Go module mirror run by Google and fall back to a direct connection
if the proxy reports that it does not have the module (HTTP error 404 or 410).
See https://proxy.golang.org/privacy for the service's privacy policy.
If GOPROXY is set to the string "direct", downloads use a direct connection
to source control servers. Setting GOPROXY to "off" disallows downloading
modules from any source. Otherwise, GOPROXY is expected to be a comma-separated
list of the URLs of module proxies, in which case the go command will fetch
modules from those proxies. For each request, the go command tries each proxy
in sequence, only moving to the next if the current proxy returns a 404 or 410
HTTP response. The string "direct" may appear in the proxy list,
to cause a direct connection to be attempted at that point in the search.
Any proxies listed after "direct" are never consulted.

The GOPRIVATE and GONOPROXY environment variables allow bypassing
the proxy for selected modules. See 'go help module-private' for details.

No matter the source of the modules, the go command checks downloads against
known checksums, to detect unexpected changes in the content of any specific
module version from one day to the next. This check first consults the current
module's go.sum file but falls back to the Go checksum database, controlled by
the GOSUMDB and GONOSUMDB environment variables. See 'go help module-auth'
for details.

See 'go help goproxy' for details about the proxy protocol and also
the format of the cached downloaded packages.

## Modules and vendoring

When using modules, the go command typically satisfies dependencies by
downloading modules from their sources and using those downloaded copies
(after verification, as described in the previous section). Vendoring may
be used to allow interoperation with older versions of Go, or to ensure
that all files used for a build are stored together in a single file tree.

The command 'go mod vendor' constructs a directory named vendor in the main
module's root directory that contains copies of all packages needed to support
builds and tests of packages in the main module. 'go mod vendor' also
creates the file vendor/modules.txt that contains metadata about vendored
packages and module versions. This file should be kept consistent with go.mod:
when vendoring is used, 'go mod vendor' should be run after go.mod is updated.

If the vendor directory is present in the main module's root directory, it will
be used automatically if the "go" version in the main module's go.mod file is
1.14 or higher. Build commands like 'go build' and 'go test' will load packages
from the vendor directory instead of accessing the network or the local module
cache. To explicitly enable vendoring, invoke the go command with the flag
-mod=vendor. To disable vendoring, use the flag -mod=mod.

Unlike vendoring in GOPATH, the go command ignores vendor directories in
locations other than the main module's root directory.

## ??

默认 $GOPATH 路径下的模块支持是禁用的，所以要使用模块支持，把目录建立在 $GOPATH
路径之外。

`go.mod` 中的依赖是按模块为基本单位的，不可以模块中的包为基本单位

`go help mod`

`go help gopath`
